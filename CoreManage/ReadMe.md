========================================================================
    控制台应用程序：CoreManage 项目概述
========================================================================
##2018年7月7日
Hi本项目是一个进步！
本项目的组成是这样的：

```
class NodesManage;  //易                                      √
class SymbolsManage;//每个节点类型都要注册: 存储NodesManage的指针  √
class StringAnaly;  //
```
我将对其难点进行分析：
- `class NodesManage;`预计难点是：
node的设计:我预备添加数种基础类型的存储。虽然似乎增加了大小，
但我不想过早优化，特别是对于这个有挑战的项目。
```
struct value{
float;
char;
double;
LONG64;//我不打算支持long long
std::string;
}
struct node{
string type;
value node_value;
list<node> child_list;
}
```
这样似乎就简单了。
接口:
SetValue
深度优先遍历？->基本类型？死循环？{
每个结构都会先搜索在符号表。
有 就结束。
没有 就注册:继续遍历。

问题:
如何返回父亲节点？
答：一般不需要返回父亲节点，因为这是一个从
树叶开始构建的过程。
只有特殊情况,eg:
map,vector中嵌套新的复合定义
map<int,map<float,int>> a;//处理int和float节点
的时候有返回需求。

vector和map与struct相比还是不同的，
vector是数组:
map是key-value数组
struct不是数组


}


###class SymbolsManage的设计
只用一个vector来保存所有类型及其指针的情况下，类似于所有的类型都是全局类型。
```
struct b{
float temp2;
}
struct a{
    struct b{
    int a;
    }
    b temp;    
}

```
此时的b是哪个呢？
符号管理如果要支持不同作用域，就需要一种数据结构来保存此关系，NodeManage中的节点比较适合。
有以下需求：
- 某节点(作用域)下一级查找某 结构名
- 找不到，就递归返回上一级查找
    - 找不到：
        报未知结构
    - 找到：
        即使用该结构
所有的结构是子结构：
{
发现一个情况：所有的结构只是缺乏全局作用域而已

也就是说所有的节点的父节点都是全局作用域而已
向当前节点的平级节点发起查询，向父节点的平级节点发起查询。
}
/*
能对指定节点的子节点们copy吗：可以。
符号表管理：全局作用域。

需要实现接口：
1. 获得指定node子树的拷贝
2. 查找从指定节点的作用域及父节点的作用域中是否存在该值
及全局作用域
3. 遍历打印类型树

节点添加：要不要依旧统一管理？
    nowNode

当前节点为空，则是全局作用域？

*/

struct b{
    struct a{
    }       
    a b;
}
多级作用域均已实现。
下一步便是：
字符串分析:
- 正则与定义类型
- XXX字符的分析
2018年7月9日星期一 1:12。